<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Linear Gaussian State Space</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="gaussian_linear_state_space_files/libs/clipboard/clipboard.min.js"></script>
<script src="gaussian_linear_state_space_files/libs/quarto-html/quarto.js"></script>
<script src="gaussian_linear_state_space_files/libs/quarto-html/popper.min.js"></script>
<script src="gaussian_linear_state_space_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="gaussian_linear_state_space_files/libs/quarto-html/anchor.min.js"></script>
<link href="gaussian_linear_state_space_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="gaussian_linear_state_space_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="gaussian_linear_state_space_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="gaussian_linear_state_space_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="gaussian_linear_state_space_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Linear Gaussian State Space</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>We will use the notation and follow chapter 6 of <span class="citation" data-cites="ShumwayStoffer">(<a href="#ref-ShumwayStoffer" role="doc-biblioref">Shumway and Stoffer 2005</a>)</span>.</p>
<section id="general-linear-gaussian-state-space" class="level2">
<h2 class="anchored" data-anchor-id="general-linear-gaussian-state-space">General Linear Gaussian State Space</h2>
<p><span id="eq-state-space"><span class="math display">\[
\begin{align}
x_{t} &amp;= \Phi_t x_{t-1} + \Upsilon_t u_t + w_t \\
y_t &amp;= A_t x_t + \Gamma_t u_t + v_t \\
w_t &amp; \sim N(0, Q_t) \quad \text{i.i.d} \\
v_t &amp; \sim N(0, R_t) \quad \text{i.i.d} \\
w_{t_i} &amp; \perp v_{t_j} \quad \forall \quad t_i, t_j
\end{align}
\tag{1}\]</span></span></p>
<p>where</p>
<ul>
<li><p>Vectors</p>
<ul>
<li><p><span class="math inline">\(x_t\)</span> : state vector (p x 1)</p></li>
<li><p><span class="math inline">\(y_t\)</span> : observation vector (q x 1)</p></li>
<li><p><span class="math inline">\(u_t\)</span> : exogenous input vector (r x 1)</p></li>
</ul></li>
</ul>
</section>
<section id="notation" class="level2">
<h2 class="anchored" data-anchor-id="notation">Notation</h2>
<p><span id="eq-conditional-mean"><span class="math display">\[
x^{s}_t = E(x_t|y_{1:s})
\tag{2}\]</span></span></p>
<p><span id="eq-conditional-covariance"><span class="math display">\[
P^{s}_{t1,t2} = E\{(x_{t_1} - x^s_{t_1})(x_{t_2} - x^s_{t_2})^\top|y_{1:s}\}
\tag{3}\]</span></span></p>
<p>where for ease of notation <span class="math inline">\(P^{s}_{t} := P^{s}_{t,t}\)</span>.</p>
<p><span class="math inline">\(y_{t,i}\)</span> is the <span class="math inline">\(i^{th}\)</span> component of <span class="math inline">\(y_t\)</span>.</p>
</section>
<section id="kalman-filter-and-smoother" class="level2">
<h2 class="anchored" data-anchor-id="kalman-filter-and-smoother">Kalman Filter and Smoother</h2>
<section id="kalman-filter" class="level3">
<h3 class="anchored" data-anchor-id="kalman-filter">Kalman Filter</h3>
<p>Assuming known initial conditions <span class="math inline">\(x^0_0\)</span> and <span class="math inline">\(P^0_0\)</span> we have</p>
<section id="prediction" class="level4">
<h4 class="anchored" data-anchor-id="prediction">Prediction</h4>
<p><span id="eq-filter-state"><span class="math display">\[
x^{t-1}_t = \Phi_t x^{t-1}_{t-1} + \Upsilon_t u_t
\tag{4}\]</span></span></p>
<p><span id="eq-filter-covariance"><span class="math display">\[
P^{t-1}_t = \Phi_t P^{t-1}_{t-1} \Phi^{\top}_{t} + Q_t
\tag{5}\]</span></span></p>
</section>
<section id="filtering" class="level4">
<h4 class="anchored" data-anchor-id="filtering">Filtering</h4>
<p><span id="eq-predicted-state"><span class="math display">\[ x^{t}_t = x^{t-1}_{t} + K_t (y_t - A_t x^{t-1}_{t} - \Gamma u_t)  \tag{6}\]</span></span></p>
<p><span id="eq-predicted-covariance"><span class="math display">\[ P^{t}_t = (I - K_t A_t)P^{t-1}_t  \tag{7}\]</span></span></p>
<p>Where the Kalman gain is</p>
<p><span class="math display">\[
K_t = P^{t-1}_t A^\top_t(A_t P^{t-1}_t A^{\top}_t + R_t)^{-1}
\]</span></p>
<p>Innovations and their covariance are then defined as</p>
<p><span id="eq-innovations"><span class="math display">\[
\epsilon_t = y_t - E(y_t|y_{1:(t-1)}) = y_t - A_t x^{t-1}_t - \Gamma u_t
\tag{8}\]</span></span></p>
<p><span id="eq-innovations-covariance"><span class="math display">\[
\Gamma_t = \text{var}(\epsilon_t) = \text{var}\{A_t(x_t - x^{t-1}_t) + v_t\} = A_t P^{t-1}_t A^\top_t + R_t
\tag{9}\]</span></span></p>
</section>
</section>
<section id="kalman-smoother" class="level3">
<h3 class="anchored" data-anchor-id="kalman-smoother">Kalman Smoother</h3>
<p><span id="eq-smoothed-state"><span class="math display">\[
x^T_{t-1} = x^{t-1}_{t-1} + J_{t-1} (x^T_{t} - x^{t-1}_t)
\tag{10}\]</span></span></p>
<p><span id="eq-smoothed-covariance"><span class="math display">\[
P^T_{t-1} = P^{t-1}_{t-1} + J_{t-1}(P^T_{t} - P^{t-1}_t) J^\top_{t-1}
\tag{11}\]</span></span></p>
<p>where</p>
<p><span id="eq-smoother-gain"><span class="math display">\[
J_{t-1} = P^{t-1}_{t-1} \Phi_t (P^{t-1}_{t})^{-1}
\tag{12}\]</span></span></p>
<section id="lag-one-covariance-smoother" class="level4">
<h4 class="anchored" data-anchor-id="lag-one-covariance-smoother">Lag-One Covariance Smoother</h4>
<p><span id="eq-lagone-covariance-smoother-recursion"><span class="math display">\[
P^T_{t-1, t-2} = P^{t-1}_{t-1} J^\top_{t-2} + J_{t-1}(P^T_{t,t-1} - \Phi_t P^{t-1}_{t-1}) J^\top_{t-2}
\tag{13}\]</span></span></p>
<p>with initial condition</p>
<p><span id="eq-lagone-covariance-smoother-initialization"><span class="math display">\[
P^T_{n-1, n-2} = (I - K_n A_n) \Phi_n P^{n-1}_{n-1}
\tag{14}\]</span></span></p>
</section>
</section>
<section id="some-computational-notes" class="level3">
<h3 class="anchored" data-anchor-id="some-computational-notes">Some computational notes</h3>
<p>Since the smoother and the filter will return many covariance matrices it is convenient to save only the lower or upper diagonal elements, here this approach is used, other approaches consist in computing the Cholesky decomposition and storing that elements, this is useful for matrices that will be inverted, more useful and interesting computational facts can be found in <span class="citation" data-cites="DurbinKoopman">(<a href="#ref-DurbinKoopman" role="doc-biblioref">Durbin and Koopman 2012</a>)</span> and in NASA papers such as <span class="citation" data-cites="nasaNavigationFilter">(<a href="#ref-nasaNavigationFilter" role="doc-biblioref">J Russell Carpenter</a>)</span>.</p>
</section>
</section>
<section id="likelihood" class="level2">
<h2 class="anchored" data-anchor-id="likelihood">Likelihood</h2>
<section id="complete-data-likelihood" class="level3">
<h3 class="anchored" data-anchor-id="complete-data-likelihood">Complete Data Likelihood</h3>
<p>The two times the negative “complete data” likelihood is: <span id="eq-complete-nllik"><span class="math display">\[
\begin{aligned}
-2 \ln L_{X,Y}(\Theta) &amp;= \ln |\Sigma_0| + (x_0 - \mu_0)^\top \Sigma_0^{-1} (x_0 - \mu_0) \\
&amp;\quad + \sum^{T}_{t=1}\ln |Q_t| + \sum_{t=1}^{T} (x_t - \Phi x_{t-1} - \Upsilon_t u_t)^\top Q^{-1}_t (x_t - \Phi x_{t-1} - \Upsilon_t u_t) \\
&amp;\quad + \sum^{T}_{t=1}\ln |R_t| + \sum_{t=1}^{T} (y_t - A_t x_t -  \Gamma_t u_t)^\top R^{-1}_t (y_t - A_t x_t -  \Gamma_t u_t)
\end{aligned}
\tag{15}\]</span></span></p>
</section>
<section id="marginal-likelihood" class="level3">
<h3 class="anchored" data-anchor-id="marginal-likelihood">Marginal Likelihood</h3>
<p>Defining with <span class="math inline">\(\Theta\)</span> the vector of all unknown parameters, using <a href="#eq-innovations" class="quarto-xref">Equation&nbsp;8</a> and <a href="#eq-innovations-covariance" class="quarto-xref">Equation&nbsp;9</a> as a function of <span class="math inline">\(\Theta\)</span> the two times negative marginal likelihood for <span class="math inline">\(y\)</span> is:</p>
<p><span id="eq-marginal-nllik"><span class="math display">\[
-2 \log L_Y(\Theta) = \sum^{T}_{t = 1}\log |\Sigma_t(\Theta)| + \sum^{T}_{t=1} \epsilon^\top_t (\Theta) \Sigma^{-1}_t(\Theta) \epsilon_t (\Theta)
\tag{16}\]</span></span></p>
</section>
</section>
<section id="model-restrictions" class="level2">
<h2 class="anchored" data-anchor-id="model-restrictions">Model Restrictions</h2>
<p>Before proceeding to estimation we focuse on a restricted subset of models.</p>
<section id="constant-matrices-and-covariances" class="level3">
<h3 class="anchored" data-anchor-id="constant-matrices-and-covariances">Constant matrices and covariances</h3>
<p>A possible but still quite general model restriction is</p>
<p><span id="eq-state-space-time-fixed"><span class="math display">\[
\begin{align}
x_{t} &amp;= \Phi x_{t-1} + w_t \\
y_t &amp;= A x_t + \Gamma_t u + v_t \\
w_t &amp; \sim N(0, Q) \quad \text{i.i.d} \\
v_t &amp; \sim N(0, R) \quad \text{i.i.d}
\end{align}
\tag{17}\]</span></span></p>
<p>with complete twice negative log likelihood:</p>
<p><span id="eq-complete-nllik-reduced"><span class="math display">\[
\begin{aligned}
-2 \ln L_{X,Y}(\Theta) &amp;= \ln |\Sigma_0| + (x_0 - \mu_0)^\top \Sigma_0^{-1} (x_0 - \mu_0) \\
&amp;\quad + T \ln |Q| + \sum_{t=1}^{T} (x_t - \Phi x_{t-1})^\top Q^{-1} (x_t - \Phi x_{t-1}) \\
&amp;\quad + T \ln |R| + \sum_{t=1}^{T} (y_t - A x_t -  \Gamma_t u)^\top R^{-1} (y_t - A x_t -  \Gamma_t u)
\end{aligned}
\tag{18}\]</span></span></p>
</section>
</section>
<section id="parameters-estimation" class="level2">
<h2 class="anchored" data-anchor-id="parameters-estimation">Parameters estimation</h2>
<p>In the following we assume <span class="math inline">\(\Gamma_t\)</span> time varying but known while <span class="math inline">\(u\)</span> is fixed but unknown. The zero state mean <span class="math inline">\(\mu_0\)</span> and zero state covariance matrix <span class="math inline">\(\Sigma_0\)</span> will be treated as unknown parameters. Note that there’s a vast literature about the diffuse initialization of the Kalman Filter (see for example chapter 5 of <span class="citation" data-cites="DurbinKoopman">(<a href="#ref-DurbinKoopman" role="doc-biblioref">Durbin and Koopman 2012</a>)</span>) but here is not taken into consideration due to time limitations.</p>
<p>Since all the distribution are assumed known a natural way to estimate the parameters is to maximize the likelihood, there are many possibile methods: among others the usually employed ones are the Netwon-Raphson (NR) or the Expectation Maximization (EM).</p>
<p>The NR requires evaluation of Gradient and Hessian, which in some cases have to be computed numerically, while the EM doesn’t. It is a common strategy to start the procedure with EM and after switch to NR, here only the EM will be considered.</p>
<section id="expectation-maximization" class="level3">
<h3 class="anchored" data-anchor-id="expectation-maximization">Expectation Maximization</h3>
<p>Following <span class="citation" data-cites="ShumwayStoffer">(<a href="#ref-ShumwayStoffer" role="doc-biblioref">Shumway and Stoffer 2005</a>)</span>, with the slight differences of the inclusion of the exogenous term <span class="math inline">\(u\)</span>; to ensure identifiability, we initally consider known the matrix <span class="math inline">\(A\)</span> so <span class="math inline">\(\Theta\)</span> holds all elements of <span class="math inline">\(\{\Phi,Q,R,u\}\)</span>. We report the EM relative to this problem. The iteration <span class="math inline">\(j^{\text{th}}\)</span> of EM consists in the update <span id="eq-em-general-update"><span class="math display">\[
\Theta^{j} = \text{argmin}_{\Theta} \{ Q(\Theta|\Theta^{j-1}) \} = \text{argmin}_{\Theta} \{E[-2 \log L_{X,Y}(\Theta) | y_{1:T}, \Theta^{j-1}] \}
\tag{19}\]</span></span></p>
<p>In the scenario considered and using trace property: <span id="eq-em-conditional-complete-nllik"><span class="math display">\[
\begin{aligned}
Q(\Theta|\Theta^{j-1}) &amp;= \ln |\Sigma_0| + \text{tr} \left\{ \Sigma_0^{-1} [ P^T_0  + (x^T_0 - \mu_0) (x^T_0 - \mu_0)^\top] \right\}   \\
&amp;\quad + T \ln |Q| + \text{tr} \left\{ Q^{-1}[S_{11} - S_{10} \Phi^{\top} - \Phi S_{10}^\top + \Phi S_{00} \Phi^\top ]  \right\} \\
&amp;\quad + T \ln |R| +  \text{tr} \left\{R^{-1} \left[  \left( \sum_{t=1}^{T} \psi_t \psi^\top_t \right) - A \left( \sum_{t=1}^{T} x^T_t \psi^\top_t \right) - \left( \sum_{t=1}^{T} x^T_t \psi^\top_t \right)^\top A^\top + A S_{11} A^\top \right] \right\}
\end{aligned}
\tag{20}\]</span></span></p>
<p>where</p>
<p><span id="eq-em-moments"><span class="math display">\[
\begin{align}
S_{00} &amp;= \sum^{T}_{t = 1} x^T_{t-1} (x^T_{t-1})^\top + P^T_{t-1} \\
S_{10} &amp;= \sum^{T}_{t = 1} x^T_t (x^T_{t-1})^\top + P^T_{t,t-1} \\
S_{11} &amp;= \sum^{T}_{t = 1} x^T_t (x^T_{t})^\top + P^T_{t,t}
\end{align}
\tag{21}\]</span></span></p>
<p>and</p>
<p><span id="eq-fixed-eff-error"><span class="math display">\[
\psi_t = y_t - \Gamma_t u
\tag{22}\]</span></span></p>
<p>The EM fully analytical updates are then</p>
<p><span id="eq-Phi-update"><span class="math display">\[
\Phi^j = S_{10} S_{11}^{-1}
\tag{23}\]</span></span></p>
<p><span id="eq-Q-update"><span class="math display">\[
Q^j = T^{-1}(S_{11} - S_{10} S^{-1}_{00} S^\top_{10})
\tag{24}\]</span></span></p>
<p><span id="eq-R-update"><span class="math display">\[
R^j = T^{-1} \left[ \left( \sum_{t=1}^{T} \psi_t \psi^\top_t \right) - A \left( \sum_{t=1}^{T} x^T_t \psi^\top_t \right) - \left( \sum_{t=1}^{T} x^T_t \psi^\top_t \right)^\top A^\top + A S_{11} A^\top \right]
\tag{25}\]</span></span></p>
<p><span id="eq-fixed-effect-update"><span class="math display">\[
u^j = \left[\sum^T_{t=1} \Gamma^\top_t \Gamma_t \right]^{-1} \left[ \sum^T_{t=1} \Gamma^\top_t (y_t - A x_t) \right]
\tag{26}\]</span></span></p>
<p><span id="eq-initial-param-updates"><span class="math display">\[
\mu_0 = x^T_0; \quad \Sigma_0 = P^T_0
\tag{27}\]</span></span></p>
</section>
<section id="missing-data" class="level3">
<h3 class="anchored" data-anchor-id="missing-data">Missing Data</h3>
<p>In case of missing data the Kalman Filter and Smoother updates won’t change much since it’s sufficient to predict the missing value. In the EM we partition the observation vector <span class="math inline">\(y_t\)</span> in <span class="math inline">\(\tilde{y_t} = \left(\left(y^{(1)}_t \right)^\top, \left(y^{(2)} _t \right)^\top \right)^\top\)</span> where <span class="math inline">\(y^{(1)}_t\)</span> is the non missing set and <span class="math inline">\(y^{(2)}_t\)</span> is the missing set at time <span class="math inline">\(t\)</span>; with an opportune permutation matrix <span class="math inline">\(D_t\)</span> we have <span class="math inline">\(y_t = D_t \tilde{y}_t\)</span>.</p>
</section>
</section>
<section id="inference" class="level2">
<h2 class="anchored" data-anchor-id="inference">Inference</h2>
<section id="numerical-hessian-and-standard-errors" class="level3">
<h3 class="anchored" data-anchor-id="numerical-hessian-and-standard-errors">Numerical Hessian and standard errors</h3>
</section>
<section id="bootstrap" class="level3">
<h3 class="anchored" data-anchor-id="bootstrap">Bootstrap</h3>
</section>
<section id="bayesian-inference" class="level3">
<h3 class="anchored" data-anchor-id="bayesian-inference">Bayesian Inference</h3>
</section>
</section>
<section id="parameters-selection" class="level2">
<h2 class="anchored" data-anchor-id="parameters-selection">Parameters selection</h2>
<section id="information-criteria" class="level3">
<h3 class="anchored" data-anchor-id="information-criteria">Information Criteria</h3>
</section>
<section id="cross---validation" class="level3">
<h3 class="anchored" data-anchor-id="cross---validation">Cross - Validation</h3>
<ul>
<li><p>Sliding window</p></li>
<li><p>Leave one station out (only for certain models)</p></li>
</ul>
</section>
</section>
<section id="hdgm" class="level2">
<h2 class="anchored" data-anchor-id="hdgm">HDGM</h2>
<section id="model" class="level3">
<h3 class="anchored" data-anchor-id="model">Model</h3>
<p>Following <span class="citation" data-cites="Otto2023">(<a href="#ref-Otto2023" role="doc-biblioref">Otto et al. 2023</a>)</span> the Hidden Dynamic Geostatistical Model (HDGM) is obtnaied imposing the following restrictions on model from <a href="#eq-state-space-time-fixed" class="quarto-xref">Equation&nbsp;17</a></p>
<p><span id="eq-hdgm-const"><span class="math display">\[
A = \alpha I, \quad \Phi = g I, \quad R = \sigma^2_Y I
\tag{28}\]</span></span></p>
<p><span id="eq-exp-cor-el"><span class="math display">\[
Q_{ij} = \exp (-|| s(y_{t,i}) - s(y_{t,j}) ||_2 / \theta)
\tag{29}\]</span></span></p>
<p>with scalars <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(|g|&lt;1\)</span> (implied stationary state autoregression structure), <span class="math inline">\(\sigma^2_{Y}, \theta &gt; 0\)</span> and <span class="math inline">\(s()\)</span> stands for the spatial point of its argument.</p>
<p>The state innovation covariance has unitary variance and exponential correlation.</p>
</section>
<section id="em" class="level3">
<h3 class="anchored" data-anchor-id="em">EM</h3>
<p>The EM updates follow the previously given ones with some changes. The ones reported are from <span class="citation" data-cites="Calculli2015">(<a href="#ref-Calculli2015" role="doc-biblioref">Calculli et al. 2015</a>)</span>, where missing data updates are present and a more general multivariate response structure is considered.</p>
<p>The update for <span class="math inline">\(g\)</span> is the univariate version of the update for <span class="math inline">\(\Phi\)</span> so the trace is taken: <span class="math inline">\(g^j = \frac{\text{tr}(S_{10})}{\text{tr}(S_{11})}\)</span>.</p>
<p>The <span class="math inline">\(\sigma^2_Y\)</span> update is <span class="math inline">\((\sigma^2_Y)^j = \frac{1}{qT} \text{tr} \left( \sum^{T}_{t=1} \Omega_t \right)\)</span> where <span class="math inline">\(\Omega_t = y_t - \Gamma_t u - Ax_t + A P^T_t A^\top\)</span>.</p>
<p>Since the scaling is given by <span class="math inline">\(\alpha\)</span>, it can’t be assumed known (at least in this parameterization) its update is <span class="math inline">\(\alpha^j = \frac{\sum^T_{t=1}\text{tr}\left(\psi_t x^\top_t \right)}{\text{tr} \left( S_{11} \right)}\)</span></p>
<p>The exponential correlation parameter <span class="math inline">\(\theta\)</span> is updated via numerical optimization:</p>
<p><span class="math inline">\(\theta^j = \text{argmin}_{\theta} \quad T\log|Q| + \text{tr} \left[Q^{-1} \left(S_{11} - S_{10} \Phi^\top - \Phi S_{10}^\top + \Phi S_{00} \Phi^\top \right) \right]\)</span>.</p>
<p>Since this is a univariate optimization problem Brent method is used, if the <span class="math inline">\(\theta\)</span> dimension increases other methods should be employed such Nelder-Mead.</p>
</section>
<section id="mcmc-and-gibbs-sampling" class="level3">
<h3 class="anchored" data-anchor-id="mcmc-and-gibbs-sampling">MCMC and Gibbs sampling</h3>
<p>Here the reference <span class="citation" data-cites="ShumwayStoffer">(<a href="#ref-ShumwayStoffer" role="doc-biblioref">Shumway and Stoffer 2005</a>)</span> and for the specific case <span class="citation" data-cites="SAHUBayes">Sahu (<a href="#ref-SAHUBayes" role="doc-biblioref">2012</a>)</span>.</p>
<p>Defining the prior on <span class="math inline">\(\Theta\)</span> with <span class="math inline">\(\pi(\Theta)\)</span> the log posterior is</p>
<p><span class="math display">\[
\begin{aligned}
\ln [\pi(\Theta|y)] &amp;= -\frac{1}{2} \ln |\Sigma_0| -\frac{1}{2} (x_0 - \mu_0)^\top \Sigma_0^{-1} (x_0 - \mu_0) \\
&amp;\quad -\frac{1}{2} T \ln |Q| -\frac{1}{2} \sum_{t=1}^{T} (x_t - \text{g} x_{t-1})^\top Q^{-1} (x_t - \text{g} x_{t-1}) \\
&amp;\quad + \frac{1}{2} q T \ln |\frac{1}{\sigma^2_Y}| -\frac{1}{2} \frac{1}{\sigma^2_Y} \sum_{t=1}^{T} (y_t - \alpha x_t -  \Gamma_t u)^\top  (y_t - \alpha x_t -  \Gamma_t u) \\
&amp; + \log[\pi(\Theta)]
\end{aligned}
\]</span></p>
<p>Prior independence is assumed among the parameters. Here <span class="math inline">\(1/\sigma^2_Y\)</span> has a <span class="math inline">\(\Gamma(a^0_{\sigma^2_Y},b^0_{\sigma^2_Y})\)</span> prior; to force stationarity <span class="math inline">\(g \sim Unif(-1,1)\)</span>; in order to ensure identifiability it has to be <span class="math inline">\(\alpha \geq 0\)</span> this can be accomplished by a reparameterization or a positive prior such as a <span class="math inline">\(\Gamma(a^0_{\alpha},b^0_{\alpha})\)</span>. The <span class="math inline">\(\theta &gt; 0\)</span> spatial distance parameter can also have a <span class="math inline">\(\Gamma(a^0_{\theta},b^0_{\theta})\)</span> prior and finally <span class="math inline">\(u \sim N_p(u_0,\sigma^2_{u_0} I_p)\)</span>.</p>
<p>At each iteration one has to sample from the conditional distributions for <span class="math inline">\(\Theta\)</span> and <span class="math inline">\(x_1, x_2, ..., x_T\)</span> given all other parameters.</p>
<section id="closed-form-updates" class="level4">
<h4 class="anchored" data-anchor-id="closed-form-updates">Closed form updates</h4>
<section id="exogenus-variables-update" class="level5">
<h5 class="anchored" data-anchor-id="exogenus-variables-update">Exogenus variables update</h5>
<p><span class="math display">\[
u^{(j)} \sim N_p\left(W \left[S + \frac{u_0}{\sigma^2_{u_0}} \right], W \right)
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\begin{align}
W^{-1} &amp;= \frac{1}{\sigma^2_{u_0}}I_p + \frac{1}{\sigma^2} \sum^T_{t = 1} \Gamma^\top_t \Gamma_t \\
S &amp;= \frac{1}{\sigma^2_Y} \sum^T_{t = 1} \Gamma^\top_t \left(y_t - \alpha x_t \right)
\end{align}
\]</span></p>
</section>
<section id="observation-error-variance-update" class="level5">
<h5 class="anchored" data-anchor-id="observation-error-variance-update">Observation error variance update</h5>
<p><span class="math display">\[
\left(\frac{1}{\sigma^2_Y}\right)^{(j)} \sim \Gamma \left(\alpha_{\sigma^2_Y} +\frac{qT}{2}, b_{\sigma^2_Y} + \frac{1}{2} \sum^T_{t=1} [y_t - \alpha x_t]^\top [y_t - \alpha x_t] \right)
\]</span></p>
</section>
<section id="state-vector-update" class="level5">
<h5 class="anchored" data-anchor-id="state-vector-update">State vector update</h5>
<p>The state vector (smoothed values) updates are from Procedure 6.1 of <span class="citation" data-cites="ShumwayStoffer">(<a href="#ref-ShumwayStoffer" role="doc-biblioref">Shumway and Stoffer 2005</a>)</span>.</p>
<p>The sampling scheme is backward from the last state (as in the Smoother case) to the first:</p>
<p>Sample <span class="math inline">\(x^T_T\)</span> from it’s filtered distribution.</p>
<p>From <span class="math inline">\(t = T-1,T-2,..,0\)</span> sample from <span class="math inline">\(p_{\Theta}(x_t|x_{t+1},y_{1:t})\)</span> i.e.&nbsp;from a <span class="math inline">\(N_q(m_t, V_t)\)</span> with <span class="math inline">\(m_t = x^t_t + J_t (x_{t+1} - x^t_{t+1})\)</span>, <span class="math inline">\(V_t = P^t_t - J_tP^t_{t+1}J^\top_t\)</span>.</p>
</section>
</section>
<section id="metropolis-hastings-updates" class="level4">
<h4 class="anchored" data-anchor-id="metropolis-hastings-updates">Metropolis Hastings updates</h4>
<section id="autoregressive-term-update" class="level5">
<h5 class="anchored" data-anchor-id="autoregressive-term-update">Autoregressive term update</h5>
<p>A resonable proposal distribution with density <span class="math inline">\(q()\)</span> is the translated Beta distribution <span class="math inline">\(Beta(\alpha_g,\beta_g,a_g,c_g)\)</span> where <span class="math inline">\(\alpha_g,\beta_g\)</span> are the usual Beta parameters and <span class="math inline">\(a_g,c_g\)</span> are respectively the minimum and maximum possible values.</p>
<p>Since <span class="math inline">\(p(g|\Theta / \{g\}) \propto \exp\left\{-\frac{1}{2} \sum_{t=1}^{T} (x_t - \text{g} x_{t-1})^\top Q^{-1} (x_t - \text{g} x_{t-1}) \right\}\)</span> the new value generated is accepted with probability <span class="math inline">\(min\left\{1, \frac{p(g^{(j)})q(g^{(j-1)})}{p(g^{(j-1)})q(g^{(j)})} \right\}\)</span>.</p>
</section>
<section id="observation-matrix-parameter-update" class="level5">
<h5 class="anchored" data-anchor-id="observation-matrix-parameter-update">Observation matrix parameter update</h5>
<p>Here, with an abuse of notation <span class="math inline">\(p(\alpha|\Theta / \{\alpha\}) \propto \Gamma(a^0_{\alpha},b^0_{\alpha})(\alpha) \exp \left\{ -\frac{1}{2} \frac{1}{\sigma^2_Y} \sum_{t=1}^{T} (y_t - \alpha x_t -  \Gamma_t u)^\top  (y_t - \alpha x_t -  \Gamma_t u) \right\}\)</span> and the proposal <span class="math inline">\(q()\)</span> is a <span class="math inline">\(\Gamma(a_{\alpha},b_{\alpha})\)</span>.</p>
</section>
<section id="theta-update" class="level5">
<h5 class="anchored" data-anchor-id="theta-update">Theta update</h5>
<p>Here <span class="math inline">\(p(\theta|\Theta / \{\theta\}) \propto \Gamma(a^0_{\theta},b^0_{\theta})(\theta) \exp\left\{ -\frac{1}{2} T \ln |Q| -\frac{1}{2} \sum_{t=1}^{T} (x_t - \text{g} x_{t-1})^\top Q^{-1} (x_t - \text{g} x_{t-1}) \right\}\)</span> and the proposal <span class="math inline">\(q()\)</span> is a <span class="math inline">\(\Gamma(a_{\theta},b_{\theta})\)</span>.</p>
</section>
</section>
</section>
</section>
<section id="model-extensions" class="level2">
<h2 class="anchored" data-anchor-id="model-extensions">Model Extensions</h2>
<p>Obviuolsy there is an infinity of possibilities to extend the model, we’ll mention some of them.</p>
<section id="increase-the-number-of-parameters-in-hdgm" class="level3">
<h3 class="anchored" data-anchor-id="increase-the-number-of-parameters-in-hdgm">Increase the number of parameters in HDGM</h3>
<p>More specifically allowing each diagonal elements to have a distinct value in the autoregression equations, observation matrix equation and observation error covariance.</p>
</section>
<section id="remove-the-parametric-spatial-covariance-assumption" class="level3">
<h3 class="anchored" data-anchor-id="remove-the-parametric-spatial-covariance-assumption">Remove the parametric spatial covariance assumption</h3>
</section>
<section id="add-time-varying-covariates-instead-of-fixed-effetcs" class="level3">
<h3 class="anchored" data-anchor-id="add-time-varying-covariates-instead-of-fixed-effetcs">Add time varying covariates instead of fixed effetcs</h3>
</section>
<section id="go-over-the-linear-gaussian-distribution-assumption" class="level3">
<h3 class="anchored" data-anchor-id="go-over-the-linear-gaussian-distribution-assumption">Go over the linear Gaussian distribution assumption</h3>
<p>Use models such the extended Kalman Filter <span class="citation" data-cites="DurbinKoopman">(<a href="#ref-DurbinKoopman" role="doc-biblioref">Durbin and Koopman 2012</a>)</span> or consider the quantile dynamic models.</p>
<section id="hmm-models" class="level4">
<h4 class="anchored" data-anchor-id="hmm-models">HMM models</h4>
<p><span class="citation" data-cites="ShumwayStoffer">(<a href="#ref-ShumwayStoffer" role="doc-biblioref">Shumway and Stoffer 2005</a>)</span></p>
</section>
</section>
</section>
<section id="references" class="level2 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Calculli2015" class="csl-entry" role="listitem">
Calculli, Crescenza, Alessandro Fassò, Francesco Finazzi, Alessio Pollice, and Annarita Turnone. 2015. <span>“Maximum Likelihood Estimation of the Multivariate Hidden Dynamic Geostatistical Model with Application to Air Quality in Apulia, Italy.”</span> <em>Environmetrics</em> 26 (6): 406–17. https://doi.org/<a href="https://doi.org/10.1002/env.2345">https://doi.org/10.1002/env.2345</a>.
</div>
<div id="ref-DurbinKoopman" class="csl-entry" role="listitem">
Durbin, and Koopman. 2012. <span>“Time Series Analysis by State Space Methods.”</span>
</div>
<div id="ref-nasaNavigationFilter" class="csl-entry" role="listitem">
J Russell Carpenter, Christopher N. D’Souza. <span>“Navigation Filter Best Practices - NASA Technical Reports Server (NTRS) — Ntrs.nasa.gov.”</span> <a href="https://ntrs.nasa.gov/citations/20250002787">https://ntrs.nasa.gov/citations/20250002787</a>.
</div>
<div id="ref-Otto2023" class="csl-entry" role="listitem">
Otto, Philipp, Alessandro Moro, Jacopo Rodeschini, Qendrim Shaboviq, Rosalba Ignaccolo, N. Golini, Michela Cameletti, Paolo Maranzano, Francesco Finazzi, and Alessandro Fassò. 2023. <span>“Spatiotemporal Modelling of PM 2.5 Concentrations in Lombardy (Italy) -a Comparative Study.”</span> <a href="https://doi.org/10.48550/arXiv.2309.07285">https://doi.org/10.48550/arXiv.2309.07285</a>.
</div>
<div id="ref-SAHUBayes" class="csl-entry" role="listitem">
Sahu, Sujit K. 2012. <span>“16 - Hierarchical Bayesian Models for Space–Time Air Pollution Data.”</span> Edited by Tata Subba Rao, Suhasini Subba Rao, and C. R. Rao, Handbook of statistics, 30: 477–95. https://doi.org/<a href="https://doi.org/10.1016/B978-0-444-53858-1.00016-8">https://doi.org/10.1016/B978-0-444-53858-1.00016-8</a>.
</div>
<div id="ref-ShumwayStoffer" class="csl-entry" role="listitem">
Shumway, Robert H., and David S. Stoffer. 2005. <em>Time Series Analysis and Its Applications (Springer Texts in Statistics)</em>. Berlin, Heidelberg: Springer-Verlag.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>